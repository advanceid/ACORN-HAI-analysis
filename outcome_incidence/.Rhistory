group = factor(as.character(group), levels = group_levels)
) %>%
dplyr::select(analysis, category, group, est, lcl, ucl)
return(out)
} else {
# Fallback: read per-pathogen sheet (e.g., "VAP_CRA")
fallback_sheet <- paste0(sheet_key, "_", category)
if (!.sheet_exists(fallback_sheet)) {
stop("Neither consolidated sheet '", preferred,
"' nor fallback sheet '", fallback_sheet, "' exists in: ", xlsx_in)
}
dat <- .read_sheet(fallback_sheet)
# Expect columns: group, est, lcl, ucl (as in earlier per-pathogen tables)
req_cols <- c("group", "est", "lcl", "ucl")
if (!all(req_cols %in% names(dat))) {
stop("Fallback sheet '", fallback_sheet, "' is missing required columns: ",
paste(setdiff(req_cols, names(dat)), collapse = ", "))
}
out <- dat %>%
dplyr::mutate(
analysis = analysis_label,
category = category,
group = factor(as.character(group), levels = group_levels)
) %>%
dplyr::select(analysis, category, group, est, lcl, ucl)
return(out)
}
}
# Build plotting data
df_plot <- purrr::map_dfr(
seq_len(nrow(analysis_map)),
function(i) {
ak <- analysis_map$sheet_key[i]
al <- analysis_map$analysis_label[i]
purrr::map_dfr(categories, ~ .fetch_block(ak, al, .x))
}
)
# Ensure numeric
num_cols <- c("est", "lcl", "ucl")
df_plot[num_cols] <- lapply(df_plot[num_cols], function(x) suppressWarnings(as.numeric(x)))
# Factor orders for facets
df_plot <- df_plot %>%
dplyr::mutate(
category = factor(category, levels = categories),
analysis = factor(analysis, levels = analysis_map$analysis_label)
)
# Group order
lvl_y <- rev(c("High income","Upper middle income","Lower middle income","Overall"))
# log estimate
all_pos <- c(df_plot$est, df_plot$lcl, df_plot$ucl)
min_pos <- suppressWarnings(min(all_pos[all_pos > 0], na.rm = TRUE))
eps <- max(min_pos/2, 0.05)
# Plot data
df_all <- df_plot %>%
mutate(
group = factor(as.character(group), levels = lvl_y),
is_overall = (group == "Overall"),
est_p = pmax(est, eps),
lcl_p = pmax(lcl, eps),
ucl_p = pmax(ucl, eps)
)
df_income <- df_all %>% filter(!is_overall)
df_over <- df_all %>% filter(is_overall) %>% distinct(analysis, category, group, est_p, lcl_p, ucl_p)
# x log breaks
x_max <- max(df_all$ucl_p, na.rm = TRUE)
log_breaks <- 10^seq(floor(log10(eps)), ceiling(log10(x_max)), by = 1)
# Plot
p <- ggplot() +
# Income groups
geom_errorbarh(
data = df_income,
aes(y = group, xmin = lcl_p, xmax = ucl_p, colour = group),
height = 0.25, linewidth = 0.25, show.legend = TRUE
) +
geom_point(
data = df_income,
aes(x = est_p, y = group, colour = group),
shape = 19,
size = 0.5, show.legend = TRUE
) +
# Overall
geom_errorbarh(
data = df_over,
aes(y = group, xmin = lcl_p, xmax = ucl_p),
height = 0.25, linewidth = 0.25, colour = "black", show.legend = FALSE
) +
geom_point(
data = df_over,
aes(x = est_p, y = group),
shape = 18,
size = 2, colour = "black", show.legend = FALSE
) +
facet_grid(rows = vars(category), cols = vars(analysis)) +
scale_x_log10(
name = NULL,
breaks = log_breaks,
labels = scales::label_number(accuracy = 1, trim = TRUE, big.mark = ""),
limits = c(eps, x_max+200),
expand = expansion(mult = c(0.02, 0.06))
) +
scale_y_discrete(name = NULL, drop = FALSE) +
theme_minimal(base_family = base_family, base_size = 10) +
theme(
panel.grid.minor = element_blank(),
axis.text.y  = element_text(),
axis.ticks.y = element_blank(),
axis.text.x  = element_text(angle = 0, hjust = 0.5),
strip.text.x = element_text(face = "bold"),
strip.text.y = element_text(face = "bold"),
strip.background = element_rect(fill = "grey80", color = NA),
legend.position = "none",
plot.margin = margin(6,8,6,8),
panel.spacing.x = unit(1, "lines")
) +
scale_colour_manual(
values = c(
"High income" = "#004488",
"Upper middle income" = "#BB5566",
"Lower middle income"  = "#DDAA33",
)
)
# Clear
rm(list = ls())
# Load packages
suppressPackageStartupMessages({
require(pacman)
pacman::p_load(
readxl, dplyr, tidyr, ggplot2, forcats,
Cairo, ggh4x, ggpp, purrr, scales, stringr
)
})
# Inputs / outputs
xlsx_in  <- "output/incidence_meta_summaries.xlsx"
pdf_out  <- "pdf/summary/incidence_summary.pdf"
# Figure setup
base_family <- "Times"
fig_width   <- 7
fig_height  <- 4
# Only three pathogens
categories <- c("CRA", "3GCRE", "CRE")
analysis_map <- tibble::tribble(
~sheet_key, ~analysis_label,
"VAP",      "VAP\n(per 10000 ICU-days)",
"BSI_ICU",  "Hospital-acquired BSI\n(per 10000 ICU-days)",
"BSI_ALL",  "Hospital-acquired BSI\n(per 10000 patient-days)"
)
pathogen_sheet_map <- tibble::tribble(
~sheet_key, ~sheet_name,
"VAP", "VAP_pathogens_all",
"BSI_ICU",  "BSI_ICU_pathogens_all",
"BSI_ALL",  "BSI_ALL_pathogens_all"
)
# Group order
group_levels <- c("High income", "Upper middle income", "Lower middle income", "Overall")
# Helpers
.read_sheet <- function(sheet_name) {
dat <- suppressWarnings(readxl::read_excel(xlsx_in, sheet = sheet_name))
names(dat) <- tolower(names(dat))
dat
}
.sheet_exists <- function(sheet_name) {
sheet_name %in% readxl::excel_sheets(xlsx_in)
}
# Fetch all rows (HI/UMI/LMI + Overall) for a given pathogen in a given analysis,
# using consolidated sheet if present; otherwise fall back to per-pathogen sheet.
.fetch_block <- function(sheet_key, analysis_label, category) {
# Preferred consolidated sheet name
preferred <- pathogen_sheet_map %>%
dplyr::filter(sheet_key == !!sheet_key) %>%
dplyr::pull(sheet_name)
stopifnot(length(preferred) == 1)
if (.sheet_exists(preferred)) {
# Use consolidated sheet and filter by pathogen
dat <- .read_sheet(preferred)
req_cols <- c("pathogen", "group", "est", "lcl", "ucl")
if (!all(req_cols %in% names(dat))) {
stop("Consolidated sheet '", preferred, "' is missing required columns: ",
paste(setdiff(req_cols, names(dat)), collapse = ", "))
}
out <- dat %>%
dplyr::filter(.data[["pathogen"]] == category) %>%
dplyr::mutate(
analysis = analysis_label,
category = category,
group = factor(as.character(group), levels = group_levels)
) %>%
dplyr::select(analysis, category, group, est, lcl, ucl)
return(out)
} else {
# Fallback: read per-pathogen sheet (e.g., "VAP_CRA")
fallback_sheet <- paste0(sheet_key, "_", category)
if (!.sheet_exists(fallback_sheet)) {
stop("Neither consolidated sheet '", preferred,
"' nor fallback sheet '", fallback_sheet, "' exists in: ", xlsx_in)
}
dat <- .read_sheet(fallback_sheet)
# Expect columns: group, est, lcl, ucl (as in earlier per-pathogen tables)
req_cols <- c("group", "est", "lcl", "ucl")
if (!all(req_cols %in% names(dat))) {
stop("Fallback sheet '", fallback_sheet, "' is missing required columns: ",
paste(setdiff(req_cols, names(dat)), collapse = ", "))
}
out <- dat %>%
dplyr::mutate(
analysis = analysis_label,
category = category,
group = factor(as.character(group), levels = group_levels)
) %>%
dplyr::select(analysis, category, group, est, lcl, ucl)
return(out)
}
}
# Build plotting data
df_plot <- purrr::map_dfr(
seq_len(nrow(analysis_map)),
function(i) {
ak <- analysis_map$sheet_key[i]
al <- analysis_map$analysis_label[i]
purrr::map_dfr(categories, ~ .fetch_block(ak, al, .x))
}
)
# Ensure numeric
num_cols <- c("est", "lcl", "ucl")
df_plot[num_cols] <- lapply(df_plot[num_cols], function(x) suppressWarnings(as.numeric(x)))
# Factor orders for facets
df_plot <- df_plot %>%
dplyr::mutate(
category = factor(category, levels = categories),
analysis = factor(analysis, levels = analysis_map$analysis_label)
)
# Group order
lvl_y <- rev(c("High income","Upper middle income","Lower middle income","Overall"))
# log estimate
all_pos <- c(df_plot$est, df_plot$lcl, df_plot$ucl)
min_pos <- suppressWarnings(min(all_pos[all_pos > 0], na.rm = TRUE))
eps <- max(min_pos/2, 0.05)
# Plot data
df_all <- df_plot %>%
mutate(
group = factor(as.character(group), levels = lvl_y),
is_overall = (group == "Overall"),
est_p = pmax(est, eps),
lcl_p = pmax(lcl, eps),
ucl_p = pmax(ucl, eps)
)
df_income <- df_all %>% filter(!is_overall)
df_over <- df_all %>% filter(is_overall) %>% distinct(analysis, category, group, est_p, lcl_p, ucl_p)
# x log breaks
x_max <- max(df_all$ucl_p, na.rm = TRUE)
log_breaks <- 10^seq(floor(log10(eps)), ceiling(log10(x_max)), by = 1)
# Plot
p <- ggplot() +
# Income groups
geom_errorbarh(
data = df_income,
aes(y = group, xmin = lcl_p, xmax = ucl_p, colour = group),
height = 0.25, linewidth = 0.25, show.legend = TRUE
) +
geom_point(
data = df_income,
aes(x = est_p, y = group, colour = group),
shape = 19,
size = 0.5, show.legend = TRUE
) +
# Overall
geom_errorbarh(
data = df_over,
aes(y = group, xmin = lcl_p, xmax = ucl_p),
height = 0.25, linewidth = 0.25, colour = "black", show.legend = FALSE
) +
geom_point(
data = df_over,
aes(x = est_p, y = group),
shape = 18,
size = 2, colour = "black", show.legend = FALSE
) +
facet_grid(rows = vars(category), cols = vars(analysis)) +
scale_x_log10(
name = NULL,
breaks = log_breaks,
labels = scales::label_number(accuracy = 1, trim = TRUE, big.mark = ""),
limits = c(eps, x_max+200),
expand = expansion(mult = c(0.02, 0.06))
) +
scale_y_discrete(name = NULL, drop = FALSE) +
theme_minimal(base_family = base_family, base_size = 10) +
theme(
panel.grid.minor = element_blank(),
axis.text.y  = element_text(),
axis.ticks.y = element_blank(),
axis.text.x  = element_text(angle = 0, hjust = 0.5),
strip.text.x = element_text(face = "bold"),
strip.text.y = element_text(face = "bold"),
strip.background = element_rect(fill = "grey80", color = NA),
legend.position = "none",
plot.margin = margin(6,8,6,8),
panel.spacing.x = unit(1, "lines")
)
p
# Clear
rm(list = ls())
# Load packages
suppressPackageStartupMessages({
require(pacman)
pacman::p_load(
readxl, dplyr, tidyr, ggplot2, forcats,
Cairo, ggh4x, ggpp, purrr, scales, stringr
)
})
# Inputs / outputs
xlsx_in  <- "output/incidence_meta_summaries.xlsx"
pdf_out  <- "pdf/summary/incidence_summary.pdf"
# Figure setup
base_family <- "Times"
fig_width   <- 7
fig_height  <- 4
# Only three pathogens
categories <- c("CRA", "3GCRE", "CRE")
analysis_map <- tibble::tribble(
~sheet_key, ~analysis_label,
"VAP",      "VAP\n(per 10000 ICU-days)",
"BSI_ICU",  "Hospital-acquired BSI\n(per 10000 ICU-days)",
"BSI_ALL",  "Hospital-acquired BSI\n(per 10000 patient-days)"
)
pathogen_sheet_map <- tibble::tribble(
~sheet_key, ~sheet_name,
"VAP", "VAP_pathogens_all",
"BSI_ICU",  "BSI_ICU_pathogens_all",
"BSI_ALL",  "BSI_ALL_pathogens_all"
)
# Group order
group_levels <- c("High income", "Upper middle income", "Lower middle income", "Overall")
# Helpers
.read_sheet <- function(sheet_name) {
dat <- suppressWarnings(readxl::read_excel(xlsx_in, sheet = sheet_name))
names(dat) <- tolower(names(dat))
dat
}
.sheet_exists <- function(sheet_name) {
sheet_name %in% readxl::excel_sheets(xlsx_in)
}
# Fetch all rows (HI/UMI/LMI + Overall) for a given pathogen in a given analysis,
# using consolidated sheet if present; otherwise fall back to per-pathogen sheet.
.fetch_block <- function(sheet_key, analysis_label, category) {
# Preferred consolidated sheet name
preferred <- pathogen_sheet_map %>%
dplyr::filter(sheet_key == !!sheet_key) %>%
dplyr::pull(sheet_name)
stopifnot(length(preferred) == 1)
if (.sheet_exists(preferred)) {
# Use consolidated sheet and filter by pathogen
dat <- .read_sheet(preferred)
req_cols <- c("pathogen", "group", "est", "lcl", "ucl")
if (!all(req_cols %in% names(dat))) {
stop("Consolidated sheet '", preferred, "' is missing required columns: ",
paste(setdiff(req_cols, names(dat)), collapse = ", "))
}
out <- dat %>%
dplyr::filter(.data[["pathogen"]] == category) %>%
dplyr::mutate(
analysis = analysis_label,
category = category,
group = factor(as.character(group), levels = group_levels)
) %>%
dplyr::select(analysis, category, group, est, lcl, ucl)
return(out)
} else {
# Fallback: read per-pathogen sheet (e.g., "VAP_CRA")
fallback_sheet <- paste0(sheet_key, "_", category)
if (!.sheet_exists(fallback_sheet)) {
stop("Neither consolidated sheet '", preferred,
"' nor fallback sheet '", fallback_sheet, "' exists in: ", xlsx_in)
}
dat <- .read_sheet(fallback_sheet)
# Expect columns: group, est, lcl, ucl (as in earlier per-pathogen tables)
req_cols <- c("group", "est", "lcl", "ucl")
if (!all(req_cols %in% names(dat))) {
stop("Fallback sheet '", fallback_sheet, "' is missing required columns: ",
paste(setdiff(req_cols, names(dat)), collapse = ", "))
}
out <- dat %>%
dplyr::mutate(
analysis = analysis_label,
category = category,
group = factor(as.character(group), levels = group_levels)
) %>%
dplyr::select(analysis, category, group, est, lcl, ucl)
return(out)
}
}
# Build plotting data
df_plot <- purrr::map_dfr(
seq_len(nrow(analysis_map)),
function(i) {
ak <- analysis_map$sheet_key[i]
al <- analysis_map$analysis_label[i]
purrr::map_dfr(categories, ~ .fetch_block(ak, al, .x))
}
)
# Ensure numeric
num_cols <- c("est", "lcl", "ucl")
df_plot[num_cols] <- lapply(df_plot[num_cols], function(x) suppressWarnings(as.numeric(x)))
# Factor orders for facets
df_plot <- df_plot %>%
dplyr::mutate(
category = factor(category, levels = categories),
analysis = factor(analysis, levels = analysis_map$analysis_label)
)
# Group order
lvl_y <- rev(c("High income","Upper middle income","Lower middle income","Overall"))
# log estimate
all_pos <- c(df_plot$est, df_plot$lcl, df_plot$ucl)
min_pos <- suppressWarnings(min(all_pos[all_pos > 0], na.rm = TRUE))
eps <- max(min_pos/2, 0.05)
# Plot data
df_all <- df_plot %>%
mutate(
group = factor(as.character(group), levels = lvl_y),
is_overall = (group == "Overall"),
est_p = pmax(est, eps),
lcl_p = pmax(lcl, eps),
ucl_p = pmax(ucl, eps)
)
df_income <- df_all %>% filter(!is_overall)
df_over <- df_all %>% filter(is_overall) %>% distinct(analysis, category, group, est_p, lcl_p, ucl_p)
# x log breaks
x_max <- max(df_all$ucl_p, na.rm = TRUE)
log_breaks <- 10^seq(floor(log10(eps)), ceiling(log10(x_max)), by = 1)
# Plot
p <- ggplot() +
# Income groups
geom_errorbarh(
data = df_income,
aes(y = group, xmin = lcl_p, xmax = ucl_p, colour = group),
height = 0.25, linewidth = 0.25, show.legend = TRUE
) +
geom_point(
data = df_income,
aes(x = est_p, y = group, colour = group),
shape = 19,
size = 0.5, show.legend = TRUE
) +
# Overall
geom_errorbarh(
data = df_over,
aes(y = group, xmin = lcl_p, xmax = ucl_p),
height = 0.25, linewidth = 0.25, colour = "black", show.legend = FALSE
) +
geom_point(
data = df_over,
aes(x = est_p, y = group),
shape = 18,
size = 2, colour = "black", show.legend = FALSE
) +
facet_grid(rows = vars(category), cols = vars(analysis)) +
scale_x_log10(
name = NULL,
breaks = log_breaks,
labels = scales::label_number(accuracy = 1, trim = TRUE, big.mark = ""),
limits = c(eps, x_max+200),
expand = expansion(mult = c(0.02, 0.06))
) +
scale_y_discrete(name = NULL, drop = FALSE) +
theme_minimal(base_family = base_family, base_size = 10) +
theme(
panel.grid.minor = element_blank(),
axis.text.y  = element_text(),
axis.ticks.y = element_blank(),
axis.text.x  = element_text(angle = 0, hjust = 0.5),
strip.text.x = element_text(face = "bold"),
strip.text.y = element_text(face = "bold"),
strip.background = element_rect(fill = "grey80", color = NA),
legend.position = "none",
plot.margin = margin(6,8,6,8),
panel.spacing.x = unit(1, "lines")
) +
scale_colour_manual(
values = c(
"High income" = "#004488",
"Upper middle income" = "#BB5566",
"Lower middle income"  = "#DDAA33"
)
)
# Save PDF
Cairo::CairoPDF(file = pdf_out, width = fig_width, height = fig_height,
family = base_family, onefile = TRUE)
print(p)
dev.off()
# Load package
library(magick)
# Function to crop PDFs using pdfcrop
crop_pdf <- function(input_pdf) {
command <- paste("pdfcrop", shQuote(input_pdf), shQuote(input_pdf))
system(command)
message("Cropped PDF saved to: ", input_pdf)
}
# Function to convert cropped PDFs to PNG
pdf_to_png <- function(input_pdf, output_png, dpi = 1000) {
pdf_image <- image_read_pdf(input_pdf, density = dpi)
image_write(pdf_image, path = output_png, format = "png")
message("Converted PDF to PNG: ", output_png)
}
# Locate and process all PDF files in the output folder
output_files <- list.files("pdf/summary/", pattern = "*\\.pdf$", full.names = TRUE)
# Loop through each PDF file, crop, and convert to PNG
for (file in output_files) {
# Crop the PDF
crop_pdf(file)
# Convert to PNG
png_file <- sub("\\.pdf$", ".png", file) # Replace .pdf extension with .png
pdf_to_png(file, png_file)
}
